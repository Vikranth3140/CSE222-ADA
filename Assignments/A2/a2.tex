\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage[margin=2.2cm]{geometry}

\title{Theory Assignment-2: ADA Winter-2024}
\author{Vikranth Udandarao (2022570) \and Ansh Varshney (2022083)}

\date{}
\begin{document}

\maketitle

\section{Preprocessing}
    No preprocessing is needed for this algorithm.

\section{Algorithm Description}
    The algorithm uses dynamic programming to find the maximum sum that can be obtained by choosing a subset of elements from the given array $\text{nums}$. It maintains a three-dimensional dynamic programming table $\text{dp}$, where $\text{dp}[i][rc][dc]$ represents the maximum sum achievable up to index $i$ considering $rc$ consecutive positive numbers at the end and $dc$ consecutive negative numbers at the end. The algorithm iterates through the array, updating the $\text{dp}$ table based on the current element and the states of consecutive positive and negative numbers.

\section{Subproblem Definition}
    The subproblem is defined as finding the maximum sum achievable up to index $i$ considering $rc$ consecutive positive numbers at the end and $dc$ consecutive negative numbers at the end.

\section{Recurrence of the Subproblem}
    Let $\text{dp}[i][rc][dc]$ denote the maximum sum achievable up to index $i$ considering $rc$ consecutive positive numbers at the end and $dc$ consecutive negative numbers at the end. The recurrence relation is as follows:

\[
\text{dp}[i][rc][dc] = \max\left\{
    \begin{array}{ll}
        \text{dp}[i-1][rc+1][0] + \text{nums}[i], & \text{// Consider } \text{nums}[i] \text{ as a positive number} \\
        \text{dp}[i-1][0][dc+1] - \text{nums}[i], & \text{// Consider } \text{nums}[i] \text{ as a negative number}
    \end{array}
\right\}
\]

\section{Specific Subproblem(s) to Solve the Actual Problem}
    The specific subproblem to solve the actual problem is $\text{dp}[n-1][0][0]$, where $n$ is the size of the $\text{nums}$ array. It represents the maximum sum achievable considering all elements of $\text{nums}$ with no consecutive positive or negative numbers at the end.

\section{Complexity Analysis}
    \subsection{Time Complexity}
        The algorithm iterates through the array once, and for each element, it updates the dynamic programming table in constant time. Thus, the time complexity is $O(n)$, where $n$ is the size of the input array.

    \subsection{Space Complexity}
        The algorithm uses a three-dimensional dynamic programming table of size $O(n \times 4 \times 4)$, where $n$ is the size of the input array. Hence, the space complexity is $O(n)$.
    
\section{Proof of Correctness}
    The correctness of the algorithm can be proved by induction on the indices of the array. The base case (index 0) is trivially correct. For the inductive step, assuming that the algorithm correctly computes the maximum sum up to index $i-1$, we prove that it also correctly computes the maximum sum up to index $i$. This can be done by considering all possible cases for the current element at index $i$ (positive, negative) and updating the dynamic programming table accordingly.

\section{Pseudocode}
    \begin{algorithm}
    \caption{Function to Find Maximum Subset Sum}
        \begin{algorithmic}[1]

            \Function{maxSubsetSum}{$\text{nums}$}
                \State $n \gets \text{size}(\text{nums})$
                \State $dp \gets \text{create 3D array of size} (n, 4, 4) \text{ filled with } \text{INT\_MIN}$
                \State $dp[0][0][0] \gets \text{nums}[0]$  \Comment{Base case}
                \For{$i \gets 1$ \textbf{to} $n-1$}
                    \For{$rc \gets 0$ \textbf{to} $3$}
                        \For{$dc \gets 0$ \textbf{to} $3$}
                            \State $ring \gets \text{INT\_MIN}$
                            \State $ding \gets \text{INT\_MIN}$
                            \If{$rc == 3$}
                                \State $ding \gets dp[i-1][0][dc+1] - \text{nums}[i]$
                            \ElsIf{$dc == 3$}
                                \State $ring \gets dp[i-1][rc+1][0] + \text{nums}[i]$
                            \Else
                                \State $ring \gets dp[i-1][rc+1][0] + \text{nums}[i]$
                                \State $ding \gets dp[i-1][0][dc+1] - \text{nums}[i]$
                            \EndIf
                            \State $dp[i][rc][dc] \gets \max(ring, ding)$
                        \EndFor
                    \EndFor
                \EndFor
                \State \textbf{return} $\max(dp[n-1][0][0], 0)$

                \EndFunction
        \end{algorithmic}
    \end{algorithm}

\section{Explanation of the Running Time}
    The algorithm iterates through the array once, performing constant-time operations for each element. Therefore, the time complexity is $O(n)$. Additionally, the algorithm uses a three-dimensional dynamic programming table of size $O(n \times 4 \times 4)$, resulting in a space complexity of $O(n)$.

\end{document}