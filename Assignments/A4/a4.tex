\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage[margin=2.2cm]{geometry}

\title{Theory Assignment-4: ADA Winter-2024}
\author{Vikranth Udandarao (2022570) \and Ansh Varshney (2022083)}

\date{}
\begin{document}

\maketitle


\section{Preprocessing and Assumptions}
    In this problem, we preprocess, assume or have been given the following:

    \begin{enumerate}
        \item The graph $G = (V, E)$ is a directed acyclic graph (DAG) and is given to us in the problem.
        \item Two vertices $s$ and $t$ are specified in the graph.
        \item The graph has $n$ vertices and $m$ edges.
        \item The vertices of the graph are labeled from 0 to n-1.
        \item A vertex v is defined as (s,t) cut if it is present in all the paths that can be possible from s to t. Vertex v cannot be s or t.
    \end{enumerate}


\section{Problem Formulation as a Graph Theoretic Problem}
    We know that we must find the vertices in all paths from s to t. This is equivalent to saying that on the removal of any of these vertices, we cannot reach from s to t. So, we formulate the problem as finding all vertices that, when removed, disconnect the path from $s$ to $t$ in a directed acyclic graph (DAG). This can be represented by constructing a graph where vertices are the nodes of the original DAG and edges represent the dependencies between nodes. If we take a theoretical example, nodes represent tasks in a project scheduling scenario, and directed edges represent dependencies between tasks. Although the graph in this problem has already been given to us, but if we had to construct or store the graph we could have used an adjacency list, which stores all the neighbours of each of the vertices.

    \textbf{Example:}
        Consider a graph $G$ with vertices $s, A, B, C,$ and $t$ such that $s \rightarrow A \rightarrow B \rightarrow C \rightarrow t$. Here, vertices $A, B,$ and $C$ are (s, t)-cut vertices as removing any of them disconnects the path from $s$ to $t$.


\section{Algorithm Description}
    We traversed the graph twice for this algorithm, each time using DFS. In the first traversal, we found a topological sorting of all the vertices (using DFS and stack). Since graph G is DAG, it can be linearly ordered topologically, and its topological sort will contain all the vertices. Then, we used a modified DFS based function FindCutNodes to identify which vertices are (s,t) cut.

    \subsection{Topological Sort Description}
    The Topological Sorting has been done in the following way:
        \begin{enumerate}
            \item Initialize an empty stack that will store the topological sorting.
            \item Initialize a visted$_$topo array that has n elements all initialized as 0 initially. This array will have value 0 if a vertex is not visited and 1 if it has been visited.
            \item Perform a DFS traversal starting from vertex $s$.
            \item When visiting a vertex $v$ during DFS, mark it as visited,i.e., visited$_$topo[v]=1.
            \item Now iterate through all its neighboring vertices and call the DFS function recursively for all the vertices $u$ that are not visited, i.e., visited$_$topo[u]=0.
            \item After iterating through all the neighbors of $v$, push $v$ into the stack.
            \item At the end, after all the vertices have been visited, the stack (from top to bottom following LIFO) will contain the topological sorted order of all the vertices. 
        \end{enumerate}

    \subsection{Modified DFS (FindCutNodes) Description}
    The FindCutNodes is as follows:
        \begin{enumerate}
            \item Initialize an empty set or list to store cut vertices. Call it cutnodes.
            \item Initialize an array start with n elements all equal to 0 initially. This array will store 1 if a vertex is visited (basically denotes entry).
            \item Initialize an array end with n elements all equal to 0 initially. This array will store 1 if a vertex has been visited back, i.e., recursive calls for all the neighbors of this vertex have been made, and we have returned back to this vertex (basically denotes exit).
            \item Perform DFS traversal in the topologically sorted order,i.e., call the FindCutNodes function for stack elements (in LIFO order) whose start value is 0 and pop the topmost stack element after the function has been called.
            \item When visiting a vertex $v$ during FindCutNodes function:
            \begin{itemize}
                \item Update start[v]=1.
                \item For each outgoing edge ($v, u$):
                \begin{itemize}
                    \item If $u$ has start[u] equal to 0 (the node has not been visited before) call the function again recursively for this node.
                    \item Else if suppose start[u] is 1 but end[u] is 0, that means there is no back edge from any ancestor of u to any descendant of u. This implies that u is a (s,t) cut vertex. Add it to the cutnodes array.
                \end{itemize}
            \end{itemize}
            \item After this, mark end[v]=1, showing that the traversal for this vertex has been done.
            \item After calling each vertex's function, the cutnodes array will contain all the nodes that when removed will not lead to no path left between s and t in the graph, i.e. all the (s,t) cut vertices.
        \end{enumerate}


\section{Pseudocode}
    \begin{algorithm}
    \caption{CutNodeFinder}
        \begin{algorithmic}[1]
        
        \Function{TopologicalSort}{$node, st, visited, adj[]$}
            \State $visited[node] \gets 1$ \Comment{Mark the current node as visited}
            \For{$i$ in $adj[node]$} \Comment{Iterate through the adjacent nodes}
                \If{$visited[i] = 0$} \Comment{If the adjacent node is not visited}
                    \State \Call{TopologicalSort}{$i, st, visited, adj[]$} \Comment{Recursively call TopologicalSort}
                \EndIf
            \EndFor
            \State $st.push(node)$ \Comment{Push the current node into the stack}
        \EndFunction
        
        \vspace{0.5cm}
        
        \Function{CutNodeFinder}{$node, start, end, cut\_nodes, adj[]$}
            \State $start[node] \gets 1$ \Comment{Mark the current node as visited (entry)}
            \For{$i$ in $adj[node]$} \Comment{Iterate through the adjacent nodes}
                \If{$start[i] = 0$} \Comment{If the adjacent node is not visited (entry)}
                    \State \Call{CutNodeFinder}{$i, start, end, cut\_nodes, adj[]$} \Comment{Recursively call CutNodeFinder}
                \ElsIf{$start[i] = 1$ and $end[i] = 0$} \Comment{If the adjacent node is visited but not exited}
                    \State $cut\_nodes.push\_back(i)$ \Comment{Add the current node to the cut nodes list}
                \EndIf
            \EndFor
            \State $end[node] \gets 1$ \Comment{Mark the current node as exited}
        \EndFunction
        
        \vspace{0.5cm}
        
        \Function{Main}{}
            \State $visited\_topo \gets \text{vector}(n, 0)$ \Comment{Initialize visited array for topological sort}
            \State $adj[] \gets \text{vector of adjacency lists}$ \Comment{Initialize adjacency lists}
            \State $st \gets \text{empty stack}$ \Comment{Initialize empty stack for topological sort}
            \For{$i$ from $0$ to $n-1$} \Comment{Iterate through all nodes}
                \If{$visited\_topo[i] = 0$} \Comment{If the node is not visited}
                    \State \Call{TopologicalSort}{$i, st, visited\_topo, adj[]$} \Comment{Call TopologicalSort for unvisited nodes}
                \EndIf
            \EndFor
            \State $start \gets \text{vector}(n, 0)$ \Comment{Initialize start array for CutNodeFinder}
            \State $end \gets \text{vector}(n, 0)$ \Comment{Initialize end array for CutNodeFinder}
            \State $cut\_nodes \gets \text{empty vector}$ \Comment{Initialize empty vector for cut nodes}
            \While{$st$ is not empty} \Comment{While stack is not empty}
                \State $node \gets st.top()$ \Comment{Get the top node from the stack}
                \State $st.pop()$ \Comment{Remove the top node from the stack}
                \If{$start[node] = 0$} \Comment{If the node is not visited (entry)}
                    \State \Call{CutNodeFinder}{$node, start, end, cut\_nodes, adj[]$} \Comment{Call CutNodeFinder for unvisited nodes}
                \EndIf
            \EndWhile
            \State \Return $0$ \Comment{Return success}
        \EndFunction
        
        \end{algorithmic}
    \end{algorithm}


\section{Complexity Analysis}
    \subsection{Time Complexity}
        The time complexity of the algorithm is $O(n + m)$, where $n$ is the number of vertices and $m$ is the number of edges in the graph. This complexity arises from the following key operations:
        \begin{itemize}
            \item Topological sorting using DFS: This operation traverses each vertex and its outgoing edges once, leading to a time complexity of $O(n + m)$.
            \item DFS traversal in the CutNodeFinder function: This operation also traverses each vertex and its outgoing edges once, contributing to the overall time complexity of $O(n + m)$.
        \end{itemize}

    \subsection{Space Complexity}
        The space complexity of the algorithm is $O(n)$, primarily due to the following data structures and variables:
        \begin{itemize}
            \item Visited array (visited\_topo): This array tracks visited nodes during topological sorting and DFS traversal, requiring $O(n)$ space.
            \item Adjacency lists (adj[]): These lists store the adjacency information of each vertex, contributing to the space complexity.
            \item Start and end arrays in CutNodeFinder: These arrays store information about node traversal states, requiring $O(n)$ space.
            \item Stack (st): The stack is used for topological sorting and can store up to $n$ vertices, adding $O(n)$ space complexity.
        \end{itemize}


\section{Necessary and Sufficient Conditions}
    The necessary and sufficient conditions for correctness are:
    \begin{itemize}
        \item If $low[u] \geq d[v]$ for a vertex $v$ and its child $u$, it implies that removing $v$ disconnects the path from $s$ to $t$, making $v$ a cut vertex.
    \end{itemize}


\section{Running Time Explanation}
    The running time of the algorithm is $O(n + m)$, where $n$ is the number of vertices and $m$ is the number of edges in the graph. This complexity arises from the topological sorting and DFS traversal performed in the algorithm.


\section{Proof of Correctness}
    The algorithm correctly identifies all (s, t)-cut vertices by utilizing topological sorting and DFS traversal. The necessary and sufficient conditions ensure that all vertices meeting the criteria are correctly identified as cut vertices.


\end{document}