\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage[margin=2.2cm]{geometry}

\title{Theory Assignment-3: ADA Winter-2024}
\author{Vikranth Udandarao (2022570) \and Ansh Varshney (2022083)}

\date{}
\begin{document}

\maketitle


\section{Preprocessing and Assumptions}
    In this problem, we preprocess, assume or have been given the following:

    \begin{enumerate}
        \item The graph $G = (V, E)$ is a directed acyclic graph (DAG) and is given to us in the problem.
        \item Two vertices $s$ and $t$ are specified in the graph.
        \item The graph has $n$ vertices and $m$ edges.
        \item The vertices of the graph are labeled from 0 to n-1.
        \item A vertex v is defined as (s,t) cut if it is present in all the paths that can be possible from s to t. Vertex v cannot be s or t.
    \end{enumerate}


\section{Problem Formulation as a Graph Theoretic Problem}
    We know that we must find the vertices in all paths from s to t. This is equivalent to saying that on the removal of any of these vertices, we cannot reach from s to t. So, we formulate the problem as finding all vertices that, when removed, disconnect the path from $s$ to $t$ in a directed acyclic graph (DAG). This can be represented by constructing a graph where vertices are the nodes of the original DAG and edges represent the dependencies between nodes. If we take a theoretical example, nodes represent tasks in a project scheduling scenario, and directed edges represent dependencies between tasks. Although the graph in this problem has already been given to us, but if we had to construct or store the graph we could have used an adjacency list, which stores all the neighbours of each of the vertices.

    \textbf{Example:}
        Consider a graph $G$ with vertices $s, A, B, C,$ and $t$ such that $s \rightarrow A \rightarrow B \rightarrow C \rightarrow t$. Here, vertices $A, B,$ and $C$ are (s, t)-cut vertices as removing any of them disconnects the path from $s$ to $t$.


\section{Algorithm Description}
    We traversed the graph twice for this algorithm, each time using DFS. In the first traversal, we found a topological sorting of all the vertices (using DFS and stack). Since graph G is DAG, it can be linearly ordered topologically, and its topological sort will contain all the vertices. Then, we used a modified DFS based function FindCutNodes to identify which vertices are (s,t) cut.

    \subsection{Topological Sort Description}
    The Topological Sorting has been done in the following way:
        \begin{enumerate}
            \item Initialize an empty stack that will store the topological sorting.
            \item Initialize a visted$_$topo array that has n elements all initialized as 0 initially. This array will have value 0 if a vertex is not visited and 1 if it has been visited.
            \item Perform a DFS traversal starting from vertex $s$.
            \item When visiting a vertex $v$ during DFS, mark it as visited,i.e., visited$_$topo[v]=1.
            \item Now iterate through all its neighboring vertices and call the DFS function recursively for all the vertices $u$ that are not visited, i.e., visited$_$topo[u]=0.
            \item After iterating through all the neighbors of $v$, push $v$ into the stack.
            \item At the end, after all the vertices have been visited, the stack (from top to bottom following LIFO) will contain the topological sorted order of all the vertices. 
        \end{enumerate}

    \subsection{Modified DFS (FindCutNodes) Description}
    The FindCutNodes is as follows:
        \begin{enumerate}
            \item Initialize an empty set or list to store cut vertices. Call it cutnodes.
            \item Initialize an array start with n elements all equal to 0 initially. This array will store 1 if a vertex is visited (basically denotes entry).
            \item Initialize an array end with n elements all equal to 0 initially. This array will store 1 if a vertex has been visited back, i.e., recursive calls for all the neighbors of this vertex have been made, and we have returned back to this vertex (basically denotes exit).
            \item Perform DFS traversal in the topologically sorted order,i.e., call the FindCutNodes function for stack elements (in LIFO order) whose start value is 0 and pop the topmost stack element after the function has been called.
            \item When visiting a vertex $v$ during FindCutNodes function:
            \begin{itemize}
                \item Update start[v]=1.
                \item For each outgoing edge ($v, u$):
                \begin{itemize}
                    \item If $u$ has start[u] equal to 0 (the node has not been visited before) call the function again recursively for this node.
                    \item Else if suppose start[u] is 1 but end[u] is 0, that means there is no back edge from any ancestor of u to any descendant of u. This implies that u is a (s,t) cut vertex. Add it to the cutnodes array.
                \end{itemize}
            \end{itemize}
            \item After this, mark end[v]=1, showing that the traversal for this vertex has been done.
            \item After calling each vertex's function, the cutnodes array will contain all the nodes that when removed will not lead to no path left between s and t in the graph, i.e. all the (s,t) cut vertices.
        \end{enumerate}


\section{Pseudocode}
    \begin{algorithm}
    \caption{CutNodeFinder}
        \begin{algorithmic}[1]
        \Function{TopologicalSort}{$node, st, visited, adj[]$}
            \State $visited[node] \gets 1$
            \For{$i$ in $adj[node]$}
                \If{$visited[i] = 0$}
                    \State \Call{TopologicalSort}{$i, st, visited, adj[]$}
                \EndIf
            \EndFor
            \State $st.push(node)$
        \EndFunction

\vspace{0.5cm}

        \Function{CutNodeFinder}{$node, start, end, cut\_nodes, adj[]$}
            \State $start[node] \gets 1$
            \For{$i$ in $adj[node]$}
                \If{$start[i] = 0$}
                    \State \Call{CutNodeFinder}{$i, start, end, cut\_nodes, adj[]$}
                \ElsIf{$start[i] = 1$ and $end[i] = 0$}
                    \State $cut\_nodes.push\_back(i)$
                \EndIf
            \EndFor
            \State $end[node] \gets 1$
        \EndFunction

\vspace{0.5cm}

        \Function{Main}{}
            \State $visited\_topo \gets \text{vector}(n, 0)$
            \State $adj[] \gets \text{vector of adjacency lists}$
            \State $st \gets \text{empty stack}$
            \For{$i$ from $0$ to $n-1$}
                \If{$visited\_topo[i] = 0$}
                    \State \Call{TopologicalSort}{$i, st, visited\_topo, adj[]$}
                \EndIf
            \EndFor
            \State $start \gets \text{vector}(n, 0)$
            \State $end \gets \text{vector}(n, 0)$
            \State $cut\_nodes \gets \text{empty vector}$
            \While{$st$ is not empty}
                \State $node \gets st.top()$
                \State $st.pop()$
                \If{$start[node] = 0$}
                    \State \Call{CutNodeFinder}{$node, start, end, cut\_nodes, adj[]$}
                \EndIf
            \EndWhile
            \State \Return $0$
        \end{algorithmic}
    \end{algorithm}


\section{Complexity Analysis}
    \subsection{Time Complexity}
        The time complexity of the algorithm is $O(n + m)$, where $n$ is the number of vertices and $m$ is the number of edges in the graph.
        
    \subsection{Space Complexity}
        The space complexity is $O(n)$ for storing visited nodes, adjacency lists, start and end arrays, and the stack.


\section{Necessary and Sufficient Conditions}
    The necessary and sufficient conditions for correctness are:
    \begin{itemize}
        \item If $low[u] \geq d[v]$ for a vertex $v$ and its child $u$, it implies that removing $v$ disconnects the path from $s$ to $t$, making $v$ a cut vertex.
    \end{itemize}


\section{Running Time Explanation}
    The running time of the algorithm is $O(n + m)$, where $n$ is the number of vertices and $m$ is the number of edges in the graph. This complexity arises from the topological sorting and DFS traversal performed in the algorithm.


\section{Proof of Correctness}
    The algorithm correctly identifies all (s, t)-cut vertices by utilizing topological sorting and DFS traversal. The necessary and sufficient conditions ensure that all vertices meeting the criteria are correctly identified as cut vertices.


\end{document}